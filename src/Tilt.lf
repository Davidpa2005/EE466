/**
 * Tilt.lf
 * Compute pitch and roll (degrees) from accelerometer axes (in g's).
 *
 * Conventions (common):
 *   roll  = atan2(ay, az)
 *   pitch = atan2(-ax, sqrt(ay^2 + az^2))
 *
 * Outputs are in degrees.
 */

target C {
  platform: "RP2040",
  single-threaded: true
}

preamble {=
  #include <math.h>

  // Convert radians to degrees.
  static inline float rad2deg(float r) {
    return r * (180.0f / (float)M_PI);
  }
=}

reactor Tilt {
  /** Accelerometer axes in g's. */
  input ax: float
  input ay: float
  input az: float

  /** Tilt angles in degrees. */
  output pitch: float
  output roll: float

  reaction(ax, ay, az) -> pitch, roll {=
    const float x = ax->value;
    const float y = ay->value;
    const float z = az->value;

    // Avoid division by ~0 and sqrt of tiny negatives due to float noise.
    const float denom = sqrtf((y * y) + (z * z));
    const float eps = 1e-6f;

    float roll_rad = 0.0f;
    float pitch_rad = 0.0f;

    // roll = atan2(ay, az)
    roll_rad = atan2f(y, z);

    // pitch = atan2(-ax, sqrt(ay^2 + az^2))
    if (denom > eps) {
      pitch_rad = atan2f(-x, denom);
    } else {
      // If denom is too small, pitch is ill-defined; keep at 0 to be stable.
      pitch_rad = 0.0f;
    }

    lf_set(roll,  rad2deg(roll_rad));
    lf_set(pitch, rad2deg(pitch_rad));
  =}
}